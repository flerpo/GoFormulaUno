package main

import (
	"net/http"

	_ "GoFormulaUno/kod/docs" // docs is generated by Swag CLI, you have to import it.

	"github.com/gin-gonic/gin"
	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mssql"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

var db *gorm.DB

func init() {
	//open a db connection
	var err error
	//db, err = gorm.Open("mssql", "formula:un0Unoun0@tcp(localhost:1433)/FormulaUno?charset=utf8&parseTime=True&loc=Local")
	db, err = gorm.Open("mssql", "sqlserver://formula:un0Unoun0@localhost:1433?database=labb")

	if err != nil {
		panic(err)
	}
	//Migrate the schema
	db.AutoMigrate(&trackInfoModel{})
}

type responseMessage struct {
	Status     int    `json:"status" example:200`
	Message    string `json:"message" example:"Meaningful message"`
	ResourceID int    `json:"resourceId" example:1`
}
type trackInfoModel struct {
	gorm.Model
	Trackname      string `json:"trackname"`
	Lenght         int    `json:"length"`
	OfficialRecord string `json:"official_record"`
	Country        string `json:"country" example:"Sweden"`
	LayoutImage    []byte `gorm:"size:10000" json:"layout_image"`
}

// @title GoFormulaUno
// @version 1.0
// @description Used for GoFormululaUno.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host localhost:8080
// @BasePath /api/v1
func main() {
	start()
}

func start() {
	r := gin.Default()
	url := ginSwagger.URL("doc.json") // The url pointing to API definition
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, url))
	v1 := r.Group("/api/v1/tracks")
	{
		v1.POST("/", createTrack)
		v1.GET("/", fetchAllTracks)
		v1.GET("/:id", fetchSingleTrack)
		// v1.PUT("/:id", updateTrack)
		v1.DELETE("/:id", deleteTrack)
	}

	r.Run() // listen and serve on 0.0.0.0:8080
}

func deleteTrack(c *gin.Context) {
	var single trackInfoModel
	db.Find(&single, c.Param("id"))
	db.Delete(&single)
	c.JSON(http.StatusOK, gin.H{"status": "deleted", "message": "Deleted track " + single.Trackname})
}

func fetchAllTracks(c *gin.Context) {
	var all []trackInfoModel
	db.Find(&all)
	c.JSON(http.StatusOK, all)
}

// Get single track godoc
// @Summary Get track
// @Description get track
// @Produce  json
// @Path id query string false "track search by id"
// @Success 200 {array} main.trackInfoModel
// @Failure 404 {array} main.responseMessage
// @Router /tracks/:id [get]
func fetchSingleTrack(c *gin.Context) {
	var single trackInfoModel
	db.Find(&single, c.Param("id"))
	if single.ID == 0 {
		resp := new(responseMessage)
		resp.Message = "Track not found"
		resp.Status = http.StatusNotFound
		c.JSON(http.StatusNotFound, resp)
	} else {
		c.JSON(http.StatusOK, single)
	}
}

func createTrack(c *gin.Context) {
	var json trackInfoModel
	search := new(trackInfoModel)
	if c.BindJSON(&json) == nil {
		db.Where("trackname= ?", json.Trackname).First(&search)
		if search.Trackname != "" {
			c.JSON(http.StatusConflict, gin.H{"status": http.StatusConflict, "message": "Track alreade exists", "resourceId": search.ID})
		} else {
			db.Create(&json)
			c.JSON(http.StatusCreated, gin.H{"status": http.StatusCreated, "message": "Track created successfully!", "resourceId": json.ID})
		}
	}
}
